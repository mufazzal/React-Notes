How react work under the hood: 
The main concept to remember is that it run on the basis of que.
It add the small event in the loop and keep them calling till the que is empty.
whenever you called the setstate, it will add a one event in list and return immediatly.
So when you call the setState it may not change the state immediatly, instead it will keep it in que, untill its time arrive.
So it you should expect the changed value in the callback of setstae, not in next line

------

Use of non-State variable:

In the react component you can use the non state variable, also can use it in render function. 
But This variable have very big disadvantage, it do not reflect by default on UI as the state-var.
So if you make any change in such variable and you have your render function dependent on it. You must ask
react framwork to reun the 'render' methode by itself. To do this you can either call 'forceUpdate' or 'setState({})': 

	..
	render() {... <div> {this.nonStateVar} </div>  ...}
	..
	myFun() {
		this.nonStateVar = 'newVal'
		this.setState({}) OR this.forceUpdate();
	}
	
------

Mutating state:
	Technically state is mutable object you can make any change after its initiation, But But But React strically say not to that and say
	One should not mutate the state and instead traet it like a immutable object.
	So mutating state is strongly unrecommended in react but not prohibited.
	Reason:-
	If you try to update the deep value in the state like this: 
  
		this.state.name = 'muf';
  
1.	Then render will not be called, and you have to call 'this.setState({})' or forceUpdate().
2.	if you do something like below	
		this.setState({name: 'muf'})		//ML1
		this.state.name = 'hus';			//ML2	
		
	Depending on where you are in life-cycle, the first statement may schedule the state change for later time. in that case 
	first a, event is schedule by seatState for later time. [line 'ML1']
	then the value of the name is set to 'hus'				[line 'ML2']
	then the event loop completed
	a schedule event qued for setState executed and the value is set to muf.
	
So problem here is that this kind of programming is very tricky and cause uncertain bugs. so avoid using direct mutation.
3.	Still you wants, then you can use the direct mutation, but then you you will loose following beauty of react	
	>	shouldComponentUpdate become useless
	>	batching of changes of multiple state not possible by internal framework


Nobody will stop you to mutate the stae object, but then nobody guarantee the perfetness of the code.
For immutability read 'Immutable.txt'
  

--------------
Default prop is setup in <CompName>.defaultProp and default state is set in constructor
  
Default prop is setup in <CompName>.defaultProp and default state is set in constructor

Though react says that you should use above approch for state manuplation, but most of the simple app ignore it because 
if app is not compplex then chances of error due to mutating state is less.

this.setState({name: 'muf', plac: 'pune'});
is 100% same as
var dt = {name: 'muf', plac: 'pune'};
this.setState(dt);
 
------------------------------

Almost all of the time we use JSX with the react, this JSX syntax are not a javascript. after the build with babel, it is changes in simple jsvascript see below examples :-

const hall = <Hall/>						after babel ->		var hall = _react2.default.createElement(_hall2.default, null)
const home = <div > {hall} </div>			after babel ->		var home = _react2.default.createElement('div', null, ' ', hall, ' ')
	
<Hall welcomeText='Sit in our Hall' />		after babel ->		var hall = _react2.default.createElement(_hall2.default, { welcomeText: 'Sit in our Hall' });

const hall = <div > <Hall />  </div>		after babel ->		var hall = _react2.default.createElement('div', null, ' ', _react2.default.createElement(_hall2.default, null), '  ' );	
const home = <div > Welcome to home  {hall} </div>				
											after babel ->		var home = _react2.default.createElement('div', null, ' Welcome to home  ', hall, ' ');

const hall = <div > <Hall welcomeText='Sit in our Hall'/>  </div>
											after babel ->		var hall = _react2.default.createElement('div', null, ' ', _react2.default.createElement(_hall2.default, { welcomeText: 'Sit in our Hall' }),'  ');

-----------------------------

Synthetic Event:-

React do the wrapping of JS event and create a new synthetic event. 
This event in most of the manner same as normal JS event. and have all the property of it.

Also this bubble up like normal JWS event (Of course it will, becoz synthetic is just a wrapper arounr JS envent. inside it is same.)

Also it has stopPropagation() and preventDefault(), which do the their desired functions.


All the sythetic event is came case in name.

You can assign the function refrence in it, not srring will give compilation error 
	<div onClick="asd" >						//Error	
	
If you write a plian JS like: 
	<div onClick="console.log('ddd')" >			//Error	
the above code will not register a synthetic avent, but execute the console statement immediatly at at time execution reached to this line.

bind and this:-
Here come the first diffrence, unlike JS event.
In normal js event 'this' will reprsent the element of item clickeed/hover etc. But here it is undefined always.
So you have to bind it to somthing if you want  to use 'this'
	EG:
	 <div onClick={this.hbClick.bind(this)} > </div>
	 Or
	 <div onClick={this.hbClick.bind({name: 'muf'})} > </div>


Accessing the event object: 
The first argument of callback function is the synthetic event. you can do all the operation of normal js event here.

	<div onClick={this.hbClick.bind(this)} >
	hbClick(p1) {
		console.log(p1)			// Synthetic event{.....}
		console.log(this)		// Binded object.
	}
		

Passing the data:-

	hbClick(p1, p2) { console.log(p1, p2) }
	render() 		{ return( <div onClick={this.hbClick.bind(this, 'Home-page')} > </div> }

Here is one catch, the last formal param here is the 'syn event' not the first
So 
p1: 'Home-Page'
p2: syn event


Bubbling UP: 
It also bubble up as normal and can be stopped by calling 'stopPropagation'
its default behaviour can be stopped via 'e.preventDefault'


return value in callback: 
	This make no diffrence, whatever return form 'hbClick()', goes in vain.
	
	
Event looping: 
Here come the big diffrence in JS and synthetic event.
In js event or react event, both cases we get an object of event in callback
	-	In JS event, a new object is created for every other event.
	-	Here there is one and only one event object exist, which  is used for all the event.
		this event object is reused for every event. and so give memory saving advantage and performance boost.
		
	hbClick(ev) {
		var myEv = ev;
		console.log(ev.target.id, myEv.target.id);											//con1
		setTimeout(()=>{console.log(ev.target.id, myEv.target.id)}, 3000);					//con2
	}
	render(){ <div id='homepage' onClick={this.hbClick.bind(this)} > }
	
In the function 'hbClick' object 'ev' will have alll its content till hbclick end, at the moment 'hbClick' end 'ev' goes null.
So 
in line 'con1' it will pring 'Homepage HomePage',
As the function end 'ev' and 'myEv' goes null, (ev and myEv both refer to same object, and that object will now be used for some other event happening in event)
so after 3 second when timer run, the console give error, coz now that object is null.

Though you can bypass this feature and use the 'ev/myEv' as usual event like JS.
for this just call ev/myEv.persist(); in the methode.
	
	
One more diffrence and very imp diffrence in syn event and JS event is: 
	In syn event, setState is run synchronusly 
	in JS event it run asynchrounsly
For more detail see 'rectlifecycle.txt'
---------------

What if no render methode in comp: 
	Error: TypeError: instance.render is not a function
what i no return in render
	Error: Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.
-----------------

Routing:
There are multiple libs for this but most widly used is 'react-router'.
Its main aim is to switching the proper component depending upor sub param of URL.
first you should install it by npm install.
nw import as needed

Router: Use this as main parent in which the component will shuffle.
Route:	Each indisusual component.
	
	
Router should contain all the route, and they all must lie in one child, you can wrap tem in div or switch(more recommended)
    <Router>
		<div> OR <switch>
			<Route .../>
			<Route .../>
			<Route .../>
		</div> OR </switch>
    </Router>
If you are using Link then that also must lie into the Router

	<Router>
	<div>
		<ul className="nav navbar-nav">
			<li><Link to="/">Home</Link></li>
			<li><Link to="/iList">Item List</Link></li>
			<li><Link to="/profile">profile</Link></li>
		</ul>	
	
		<Route exact path="/" component={HomPage}/>
		<Route path="/iList" component={ItemList}/>
		<Route path="/profile" component={Profile}/>
	</div>
	</Router>
Consider above code is basis for any routing, with the Link above we can do the switching below.
'to' in the 'Link' will map tp 'path' in Route.

Nesting in Route: Not allowed since v4 of this lib.

IndexRoute: 
Just remember
	<Route exact path="/" component={Home}/> === <IndexRoute component={Home}/>

VVIMP: if you redirct to subpages (<domain>/about etc.) via 'Link' or history.push() then only all thing work fine otherwise all will fall apart.
	Do not do the direct redrection or simplly typing and entering URL in browser.
History: 
first create and declare to use history in Route like below
	import createBrowserHistory from 'history/createBrowserHistory'
	const history = createBrowserHistory()
Now in Router:-
	<Router history={history}>
		...
	</Router>
this 'history' object now available in all the child route too as a props.
use below for navigation :
    this.props.history.push("/some/Path");
	
	
in Route you can also pass 'render' function or 'children' function	:-
	 <Route path={to} {...rest} render={props => (
		<FadeIn>
		  <Component {...props}/>
		</FadeIn>
	  )}/>

also see "#REFCODESPLIT" in this file.
-------
	
Fumctional Component:-
You can declare a simplest functional comoinent like below:-


	function Welcome(props) { return <h1>Hello, {props.name}</h1>; }			ES5-functional-comp
	Or
	const Welcome = (props)=>{return <div> Hello {this.props.name}</div>}		ES6-functional-comp
	
	ReactDOM.render( <Welcome name="Sara" />, document.getElementById('app') );
	
Funtional component do not have state and lifecycle methode. 
It is only useful as a pure component. 
If you want to just show thing on UI and not to hadle anything, Use this.
This is best if you wants to use a simple HTML like template with props nad no data manuplation.
This are also called Pure component or stateless-functional-conponent bcoz state is missing here.
	
Also functional component do not have 'this' attached to its instance as there is no class. 
and when you attacht the click listener then you do not have to worry about the bind.

attaching click in funcion compo:-

	function NumberListParent(props) {
		var clkFun1 = () => {....};
		return (<div onClick={clkFun1}> Change Array </div>);
		OR
		return (<div onClick={()=>{clkFun1()}}> Change Array </div>);
	} 
So you can attach the click in both way. do notice that here we declare the function 'clkFun1' in the component function 
so it will remain in closure and so props will be available for 'clkFun1'
Now suppose u declare it outside-

	var clkFun1 = (props, e) => {....};
	function NumberListParent(props) {
		return (<div onClick={clkFun1}> Change Array </div>);
		OR
		return (<div onClick={(e)=>{clkFun1(props, e)}}> Change Array </div>);
	}
Here if you do it by way 1 thaen you wil not have props injected as formal param. but in second one you do have.

Sending default props in functional Comppo-
const Component = ({ prop1, prop2 }) => ( <div></div>)
Component.defaultProps = {
  prop1: false,
  prop2: 'My Prop',
}
OR
const Component = ({ prop1 = false, prop2 = 'My Prop' }) => (
  <div></div>
)    

	
Class component:
Just extend React.Component. as we did it almost all the time (No all the time)		Es6-class-comp
Aniother way: by React.createCalls methode in ES5: 

	const Contacts = React.createClass({											Es6-class-comp			
	  propTypes: { },
	  getDefaultProps() { return { }; },
	  getInitialState() { return { }; },
	  render() { return ( <div></div> ); }
	  componentWillUpdate() {};
	  
	});
This is 100% same as simple Es6 class with those function. In all those function 'this.' will reprsent the component

React.createClass[JSX] VS React.extend{JS}:
Only one: after the compilation the ES6 code will getconverted to ES5 by bable, 
React.createClass is atready in ES5 so babled do almost nothing and generate the same amount of code 
But React.extend is ES6 so babel do lot of work, also it generate big chicnk of code in ES5 pattern So	
	1.	Increase build time
	2.	Increase file size
But then why we use 'extend' all the time: 
ANS: Simplicity
	
StateLess component: no state - better if we use function component pattern 
Statefulcomponent: with state - cant be used with functional component pattern, so onlu with class component.

-------

Renderig:
You can render this too: one lineer stateless function component
	ReactDOM.render(<h1>Hello, world</h1>, document.getElementById('root'));

----------


----

output plz-
const cc = <div> I m HomePage {false} </div> ;
Ans
 I m HomePage
 
const cc = <div> I m HomePage {false + ''} </div> ;
Ans
 I m HomePage false
-----

array and Key:
if you are creating list of component to display with an array, then you must specify the kay for each indivisual item and that key must be unique, If you dont
then there will be warning. actully React lib use internally this key to identify exach element in it.
the key must be given to the lemenet which come at top on itration by array.

EG:
	const listItems = numbers.map((number) =>
		<Welcome key={number.toString()}>
		  {number}
		</Welcome>
	  );
Never use index as key, becoz index remain same even if you chane this.setState({numbers: [55,  44, 12]})
--------
#REFRECSERVERREN

Server Side rendering;-
	When we create an app what we do usually is-
	
template.html:-

	<htm>
		<head> </head>						LHTM1
		<script>......
		<meta>.....
		<div id="contet">
			....							LHTM2
				<div id="app"> </div>
			....
		</div>
	</html>

App.js:-
	import 'react'
	imp[ort 'MyReactApp'
	...
	var App = (p) => {return <MyReactApp></MyReactApp>}

In the 'template.html' file, from line LHTM1 to LHTM2, all the part of html code is rendered at server side. 
once server side rendering is done than in side the div of id 'app' all the thing is rendered at client side.

So here all the react part appear only at client side.
But react do provide a way to do the server side rendering for react part too.

For this you need to use some APIs. 
and you need a node.js server or any other Javascript server.

In server.js >>

	import React from 'react';
	import { renderToString } from 'react-dom/server';
	import App from 'App';

	server.get('/', (req, res) => {
		...
		const body = renderToString(<App />);
		...
		
		res.send(
			<htm>
				<head> </head>						
				<script>......
				<meta>.....
				<div id="contet">
					....							
						<div id="app"> ${body} </div>
					....
				</div>
			</html>
		);
	}
Now if you load 'localhost:8080/' then the App will load as it load normally. but behind the scene rendering happen at server side.
Though this is hardly used. sever side rendering is least common becoz:-
	It take too much time to render and so engagge the server for longer time.
	This can be done inNode.js sever and as node server is single thread server and perform badly id computation is high.
	at inital loading time you can not display the 'Loading...'
This is only good if network is slow and you do not want much web service. and to show the static content
One other advantage is SEO engine read all the content.

------------------------

Key :-
If you are rendering the JSX elements via an array then you must miust provide a 'key' attribute to the each of this element.
this elemnts could be anything like, div, li, h1 of MyComp.

e.g:
	var arr = [<div>muf</div>, <div>hus</div>, <div>sha</div>]
	return <div> {arr} </div>;
This line will give warning (not error) the you must provide a key.
so correct it
	var arr = [<div key="1">muf</div>, <div key="2">hus</div>, <div key="3">sha</div>]
	return <div> {arr[0]} {arr[1]} {arr[2]} </div>;
	
Though most of the time we do it like this:-
	const numbers = [1, 2, 3, 4, 5];
	const listItems = numbers.map((number) => <li key={number.toString()}> {number} </li> );
	return <ul> {listItems} </ul>
It is not at all necessary that you must use ul and li. never confuse that array jsx is related to html ul/li.
Key is necessary only if you are rendering via a array.

This is not required in below case:-
	var arr = [<div>muf</div>, <div>hus</div>, <div>sha</div>]
	return <div> {arr[0]} {arr[1]} {arr[2]} </div>;
Why:- Internal framwork use the key for the identification of each element. and if you do not use it bug may occure.

----------------

React component composition. React.children:-
You can acess all the first level child component of any react component via this.props.children OR props.children
This will give you array of object or a single object. 
no matter anything it provide, it is in very dirty state. you should never use it directly like - 
	this.props.children.map()  --  such uses will be very buggy.
	reason: all the jsx statement may add span or empty space in virtual DOM
eg:
changeColor() {
	var testdiv = 
	<div>
		 {<div id="1"> yus </div>}
		 {<div id="2"> moz </div>}
		 {<div id="3"> azz </div>}
	 </div>;
	 const modAnchor = React.Children.map(testdiv.props.children, child =>{
	   console.log(child.props.id);
	});
}	
for any such JSX vrtual dom you can itrate the child elements in this way.
above code will print 1 2 3

use case:-
use this to itrate on child component of any react component-
	
	...
	var testdiv = 
	<div>
		 {<div id="1"> yus </div>}
		 {<div id="2"> moz </div>}
		 {<div id="3"> azz </div>}
	 </div>;
	<MyComp testdiv={testdiv} />
	...
	
	function MyComp(props) {
		const modAnchor = React.Children.map(props.testdiv.props.children, child =>{
			console.log(child.props.id);
		});
	}

---
in the above example you have container component as 'div'. this could be custom component too.
Also you know that child are created first and parent later in render cycle of react.
to get the JSX-children of any component you should use 'children' props. this is by default supply in react component.
	
	
	var testdiv = 
	<MyContainerComp>
		 {<div id="1"> yus </div>}
		 {<div id="2"> moz </div>}
		 {<div id="3"> azz </div>}
	 </MyComp>;

	function MyContainerComp(props) {
		var innerDiv = <div> {''innerdiv} </div>
		return  <div id="myc"> {props.children} {innerdiv}</div>			//CHL1
	}
Here all 3 div written in jsx syntext will appear inside the 'myc' div. so basically you can specify the exact location of 
child component added via JSX.
Here innerDiv is also a child, but innerdiv do not come in props.children because 'props.children' will only cover the
component which are added as JSX-inner-component

VVVIMP: If you are writing any container component which can have a JSX-child component. then in that component 
you must must place the 'props.render' in render methode. if you do not place it then all those child will not at all appear.

So in simple word. 'props.children' is used ti place the JSX-children component in any container-react-component.
If you change line 'CHL1' like belo:-
		return  <div id="myc"> {innerdiv}</div>
then no singler div of id 1/2/3 will come on UI.

If you pass the component via the props then use 'this.props.compPropsName' to place them at proper place
If you put component as JSX-children of any react component. then use 'this.props.children' to place them at proper place
	<MyCom byPr={<div>bypropos</div>}> 
		<div>{JSX-child}</div> 
	</MyCom>
	MyCom {  
		render() {  
			<div>{this.props.bypropos}</div>  
			<div>{this.props.childern}</div>  
			}  
		}
If you have multiple first level child then this.props.childern will be an array. 
Never iterate it directly instead use React.children.map\
diffrence betwee - 
bypropos :> this come from props and think it as a strcture of MyCom, use this.props.bypropos to itrate its children
JSX-child :> this are the child component. think it as JSX-child, use this.props.childern to itrate them

Most IMP use of this feature is to add some kind of extra feature in every child component of any container-react-comp
Suppose you wants to add two thing in each JSX-child of MyCom then follow this-
1.  itrate on all the JSX-child-component via React.children.map(this.props.children, ...)
2.  create copy of each of the child 
3.  add specific feature you wants and put it in new array of modified childs
4.  now instead of placing 'this.props.children' in jsx place 'midifiedChilds'

If you wants to add a props in each child and also wrap each child in red box-
const Accrodian1 = ({children}) => {
   
  var modChildren = React.Children.map(children, child => { 
    var cloneChild = React.cloneElement(child, {
      customProp: 'custopmPropsValue'
    });
    cloneChild = <div style={{color: "red"}}>{cloneChild}</div>;
    return cloneChild;
  });
  return (<div> {modChildren} </div>);
}

--------------------------------------------------------------------------------------------------------------------------------


Accessibility :-
It is actuly a way to make the UI more easy to use

Managing the Focus >>
you can manage the focus by using the refs. thi is very imp as it make the apliction usable and also react keep rendering the 
DOM so many time we could lost the focus to uncertain place. to regain focus to proper place do this-
	render() {
		return(
			<div>
				<input type="text" ref={(refI2_) => this.refI2 = refI2_} />
				<button onClick={()=>{this.refI2.focus()}}> click </button>
			</div>)
		}
	}
---

Fragments :-
Fragments are a pattern used in React which allow a component to return multiple elements, without an encompassing <div> component. 
Using <div> elements in certain places may create invalid HTML.
EG:-
	...
	return  <ul>  <ListItems />  </ul>
	...
	ListItem = (p) => {
		return <div> 
				<li> item 1 </li>  <li> item 2 </li> <li> item 3 </li>
			   </div>
	}
	This will give the below invalid HTML  
		<ul> <div> ....  </div> </ul>
	To avoid this u can use Fragment. Fragment will evaporated in actual DOM and not place itself on UI but render all its chillds
	Observe the change :-
		return <React.Fragment> 
				<li> item 1 </li>  <li> item 2 </li> <li> item 3 </li>
			   </React.Fragment>
	The final out:-
		<ul> <li> ....  </li> </ul>

In latest react you can also do
		<> 
			<li> item 1 </li>  <li> item 2 </li> <li> item 3 </li>
		</>
-------------------------

refs :--

we already know where we use ref. but react have made a major change in the ref.
till now wr were using ref as a sinple string but now react will soon not allow it and has already deprecated it.
for current verswion it is highly recommended that we use ref call back instead of simple string.

in callback ref you do not provide the string instead a callback function with one formal param.
this callback is called at the time of rendering and its formal param is injected by internal libs.
this injected value is a 

	<input type="text" ref={(formalRef) => this.myref = formalRef} />

here the 'this.formalRef' can be used for accessing the dom elements and function od react component.
	eg: this.myref.focus()
imp diffrence: if ref were simple string then we use 'this.refs.inputRef.focus()' but in callback ref you no need of 'refs'

For cutom component: 
	<MyComp ref={(myComRef) => this.myComRef = myComRef}/>
	click() {
		this.myComRef.anyFunctionImMyComRef();
		this.myComRef.setState({...})
	}

ref and findDOMNode :-
	findDOMNode is useful when you are using the ref as string, but as you know this is deprecated so use of 'findDOMNode' is also heavuily demoralized.
	
	
There is one more way now avilable for ref: search createRef() function.
 -
 
VVVIMP: ref can only be used if component passes from all the component lifcycle. but as you know functional component do not pass via the 
component lifecycle so we cant ise ref on function component. though we can use it insile it.
	
	MyFunctionComponent = (props) => {
		<MyClassComp ref={(q_)=q=q_}>				//This line will be fine
	}
	
	MyFunctionComponent ref={(p)=>this.p=p} />		//This line will give error
	
ref should not be used extensivly, officially it should be use only for gaining focus, scroll etc. 
never u shall call a function with ref that make state and prop changes in code.

---


gaining focus :- 
suppose you have a parent and two child. 
one child has text input and other a button. and you wants to gain a focus on text input on button click.
In the child first we will send a callback function 'onInputBoxRenderedCb' which will evoke when the input text is rendered on UI, 
we will preserve its refrence in 'onInputBoxRendered'. 

function Parent(props) {
  var onInputBoxRendered = null;
  
  var onInputBoxRenderedCb = (_onInputBoxRendered) => {
    onInputBoxRendered = _onInputBoxRendered
  }
  var gainFocusToInpText = () => {
    onInputBoxRendered.focus();
  }
  
  return( 
  <div>
    <Child1 onInputBoxRenderedCb={onInputBoxRenderedCb}/>
    <Child2 gainFocusToInpText={gainFocusToInpText}/>
  </div>);
}
var Child1 = (props) =>   { 
                            function funInChild1() {alert('funInChild1')}
                            return <div ><input type="text" ref={(e)=>{props.onInputBoxRenderedCb(e)}} /></div>;
                          }
var Child2 = (props) =>   <button onClick={props.gainFocusToInpText}>sa </button>;

Calling any user define function:-
       <Child ref={instance => { this.child = instance; }} />
       <button onClick={() => { this.child.anyChildFunction(); }}>Click</button>
   
-------------------------------------	
	
React Context:-
What you will do to set laguage, theme kind of thing in react. 
you will set it container and then drill it down to do bottom most element. so passing the props on each level from top to bottom.
and as you know this things remain almost constatnt so why so much adoo.
use context for this.

approch is:-
Step 1:	Craete context in on some top(not neccesrily topmost) level component: ThemeContext.js
			ThemeContext.js >>
			export default const ThemeContext = React.createContext();
			
Provider: This is a simple react component who has a authority to create and changes the values in the context.
			So basicaly this is the source of data in the context.
How to create Provider: 
In the step 1 you crated the context 'ThemeContext', its provider will be 'ThemeContext.Provider'
How to supply data in it
	
	import ThemeContext from './ThemeContext' 
	export default class ThemerCompo extends React.Component{
		constructor(p) { 
			super(p); this.state = {color: black, bkColor: white} 
		} 
		getTheme() {
			return {color: this.state.color, bkColor: this.state.bkColor}
		}
		render() {
			<ThemeContext.Provider value={this.getTheme()}>
				<button onclick={this.changeTheme.bind(this)}>
				<MyCompleteApp>
			</ThemeContext.Provider>
		}
		changeTheme() {
			this.setState({color: black, bkColor: white});
		}
	}
	
In this above example you can see that how we can set the values of theme by changing button, and then use the derived state 
as the data source for our theme context. whatever passed in 'value' props of 'ThemeContext.Provider', will move down in all childs.

How to read this data in child:-
First of all all this data we set in context will not move down the tree as props. so you cant read them simply as 'this.props.color/blcolor'
If you wants to read the data from this context, you have to use Consumer:
How to create Provider: 
In the step 1 you crated the context 'ThemeContext', its Consumer will be 'ThemeContext.Consumer'
Provider is only one but comsumer cam be more than one.

import {ThemeContext} from './ThemerCompo'
MyCompleteApp/DeeperComp/AnyCompInTreeofMyCompleteApp = (props) => {
	return 
		<div>
			<ThemeContext.Consumer>
				{
					theme => <div>
								My current theme data: {theme}
							 </div>
				}
			</ThemeContext.Consumer>
		</div>
}
----------------------------------------

Error Boundry:- 
error boundry is a typical react component which says. If any error occuer in any of my children component, i will take care of it.
A developer can programm me to respond in case some error occure in any of my child.
I can catch the error only if:-
1.  It happen in my children, not in a component which is passed in my props.
     <ErrorBoundry byProp={ByPropComp}>  <JSXChildren /> </ErrorBoundry>
    In above code all the erro happen in 'JSXChildren' will be handled but not of in 'ByPropComp'
2.  Error occuring only in redering cycle. eg. in any lifecycle methode. But will not handle error occure outside redering phase. 
		EG in click event etc. for handling error in event click and other non rendering phase use try/catch
3.  It will not handle any error occure in parent compo or in its own render or lifecycle methode itself

Step-
create a react component and implement one or both of this methode.
 getDerivedStateFromError: this is a static methode, which invoke when error is occured. it return the apropiate state object to handle error. 
 do not setState({..}) here
 componentDidCatch: this is also called when error occure, you can use this too. you can use setState({..}) here.
 React doc says first one is recommended to use. but do not prohibit uses of second one.
 You can see the render methode below check if error occure, if yes then show the fallback UI otherwise just render its JSX-children

IMP: this functionality available only after react16.

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null};
  }

  static getDerivedStateFromError(error) { return { hasError: true, error: error}; }
  componentDidCatch(error, info) { console.log(error, info)  }

  
  render() {
    
    if (this.state.hasError) {
      return <div>
              <h1>Something went wrsong.</h1>
              <p>{this.state.error.message}</p>
            </div>;
    }
    return this.props.children; 
  }
}

Var App = (props) => {
	return <div>
			<ErrorBoundary>
				<MyApplicatopm />
			</ErrorBoundary>
		   </div>	
}	
--------------------------------------------------
Higher-Order Components:- 
	Higher order component are built over the top of react component. this wrapper component do the abstraction
	connect function in redux also return a kind of HOC.
	though it is rarly use but for more google it.
------------

---------------------------------------------------------------

Input Elements and React -  


Whenever you are using input elements and you set the value by 'value' attribute without using onChange. then things may become very uncertain
Why?
if you do one of this
 <input value={this.state.inp} />
 <input value={this.props.inp} />
  <input value={'muf'} />
Whenever use type anything in input box, it will fire the onChange with new value. but this onchange will remain unattended as we
have not set the callback. once onChange-cycle completed the typed new value goes in the garbage. Now typing happen on actaul DOM
Not on virtual one so react framwork never know that somthing is done by user. so react engine remain unconsious of any envent.
So no matter what user type in text box, render will never be called. becoz just typing will not make any state changes to triggr the render.
And so the value in in the input box never chages. user keep pressing the key but nothing happen
So from user point of view all this three input box are readonly

If you wants to allow user to make change, the instead of value use 'defaultValue'.
this will enable the user to change the text in input-box by typing.
BUT there is still one glitch.
As you have not configure the onChange event so when user chage the value in input-box, it do reflect on UI. but react never know about this changes so 
all this changes goes in garbage and no render will be called. 
So from user prospective it is editable but at the backend it does not care about changes.

value and defaultValue together without onchange:-
if you use both then value attribute will have the priority. but if value is null or undefined then defaultValue will be populated.
otherwise always value will be populated. 
If value is not a null or undefined then element will remain readonly otherwise it will be editable for the user.
also note that if value is empty string then also value will have the priority and empty input box will be shown and remain uneditable.
 <input defaultValue={props.inp} value={undefined/null}/> : 'inp' will be shown and elemets is editable
 <input defaultValue={props.inp} value={'muf'}/>          : 'muf' will be shown and elemets is readonly
 <input defaultValue={props.inp} value={''}/>             :  elemnt is empty and readonly

In all above way we discussed the component has one thing in common 
It may be editable or not, but whatever the changes user made by typing. It will goes in vain.
In such a cases the componenet is called uncontrolled component.

Simillar thing will happen with chckboxes and checked/defaultChecked attr.

 <input type="checkbox" checked={props.inp} />
 <input type="checkbox" checked={this.state.inp} />
 <input type="checkbox" checked={true/false} />
 All above will populate the checkbox with the given value but remian uneditable for the user

checked and defaultChecked together without onchange:-
<input type="checkbox" defaultChecked={props.inp} checked={null/undefined}/>   : 'inp' will be shown and elemets is editable
<input type="checkbox" defaultChecked={props.inp} checked={true} />            :  element is checked and readonly  
<input type="checkbox" defaultChecked={props.inp} checked={'mm'} />            :  element is checked and readonly
<input type="checkbox" defaultChecked={props.inp} checked={0/false} />         :  element is unchecked and readonly

This concept is true for <textArea>, <select> and <radio> as well.

var FunComp = (props) => <input type="checkbox" checked={true} defaultChecked={props.inp}/>

class ClsComp  extends React.Component {
  constructor(props) { super(props); }
  render() { return <input defaultValue={this.props.inp} /> }
}

class ClsCompControlled  extends React.Component {
  constructor(props) { super(props); this.state={inp: this.props.inp}}
  render() { return <input defaultValue={this.state.inp} /> }
}
All above three component are read only


To make something sensible tou will have to configure the onChange. and make it a Controlled Component.
For this you have to maintain the value/checked in some state variable. As you need to have a state so you cannot use functional component here.
So you have to use class componenet. see below this basic impl

class InputBox extends React.Component {
  constructor(props) { 
    super(props); 
    this.state =  {
        inp: this.props.inp
    }
  }
  render() { 
    var input = <input 
                  defaultValue={this.state.inp} 
                  value={this.state.inp} 
                  onChange={this.onChange.bind(this)} 
                  ref={this.props.refInitForFocus}/>;
    return input;
  }
  onChange(e) {
    var v = e.target.value;
    this.setState({inp: v});
    if(this.props.onChange)
      this.props.onChange(v, e);
  }
} 

--

React and Radioo button:-
there is two way:-
1.	By simple HTML uncontrolled component.	
	render() {
		return ( 
		  <div onChange={this.setGender.bind(this)}>
			<input type="radio" value="MALE" name="gender"/> Male
			<input type="radio" value="FEMALE" name="gender"/> Female
		  </div>
		 )
	  }
But this is highly discouraged as it is uncontrolled and changes should be in synch with state and props.

instead do this:-
<input type="radio" name="site_name" 
		   value={'muf'} 
		   checked={this.state.site === result.SITE_NAME} 
		   onChange={this.onSiteChanged} />{result.SITE_NAME}</td>
<td><input type="radio" name="address" 
		   value={result.ADDRESS}  
		   checked={this.state.address === result.ADDRESS} 
		   onChange={this.onAddressChanged} />{result.ADDRESS}
		   
		   
IMP: value attribute in chechbox and radio button is for label only

------------------------------

ES6 VS ES5 in React context - 

ES6 
	class Greeting extends React.Component {
	  render() {return <h1>Hello, {this.props.name}</h1>;}
	}
	Greeting.defaultProps = {name: 'Mary'};
ES5
	var Greeting = createReactClass({
	  render/willMo/willU/didU...: function() {return <h1>Hello, {this.props.name}</h1>;}
	});
---
Functional comp 

Es5     var function Greet(props) {
         return <div> props.greet <\div>
	}
Es6     var Greet = (props) =>{
         return <div> props.greet <\div>
	 }
can not use refs in both case here at all.
---
Class comp

Es5      var Greet = React.createClass(....)

Es6      Class Greet extends React.Component {
         ....
	 }
---
defaultProps:-
Es6	  : for functional and class comp both
	Greeting.defaultProps = {name: 'Mary'};
ES5
	var Greeting = createReactClass({
		getDefaultProps: function(){ return { name: 'Mary' }; },
	});
--
propTypes:-
ES6  : for functional and class comp both
	Greeting.propTypes = {
	  initialValue: React.PropTypes.string
	};
ES5
	var Greeting = createReactClass({
			propTypes: {initialValue: React.PropTypes.string}; 
	});
--
initil state :-
Es6		: for comp only as no state in functional comp
	this.state = {...}
ES5
	getInitialState: function() {...}


 
-------------------------------JSX-------------------------

React without JSX:-
	React.createElement('div', null, `Hello ${this.props.toWhat}`);
	
	
	

----
After babel

Class MyCom extends React.Component {
..}
will be converted to
var MyCom = React.createclass(...)

var mm = <MyComp>
will be converted to

var mm = React.createelement(...MyComp...)
 



Booleans, Null, and Undefined Are Ignored :-
All below expression will render nthing -

	<div></div>
	<div>{false}</div>
	<div>{null}</div>
	<div>{undefined}</div>
	<div>{true}</div>
Though if you make the a string then it will render its content-
--

Short circuit statement + JSX:-
see #REFSHORTCUR in js.txt
Jsx also support this 
	<div>
		{ true  && <div> MUF </div>}		// first is true with AND so second also has to check. so next will be return. so 'Muf will be printed'
		{ true  || <div> MUF </div>}		// first is true with OR so second do not need to evaluate. so statement will produce a Boolean true 
		{ false && <div> MUF </div>}		// first is false with AND so do not need to evaluate. so statement will produce a Boolean false
		{ false || <div> MUF </div>}		// first is false with OR also has to check. so next will be return. so 'Muf will be printed'

		{ <div>FAT</div> || <div> MUF </div>}		// FAT
		{ <div>FAT</div> && <div> MUF </div>}		// MUF
	</div>

No just above you have read that 'Booleans, Null, and Undefined Are Ignored' so in above 4 cases out of which 2 is producing boolean
will actully render nothing on UI. no matted produced result is true or false.

This feature is very useful for conditional rendering. 
use 
	condition && <..>   for rendring if   condition === true
	condition || <..>   for rendring if   condition === false
Also
	Comp1 || Comp2		if you wants to give priority to Comp1
	Comp1 && Comp2		if you wants to give priority to Comp2

You can use null and undefined also here. they both will be treated as false and not be renderd on actual UI.
But you cannot use 0, because it will be rendered on UI.

suppose length of array is 0.
	{arr.length && arr[0]}		//This will not give any error but it will print 0 on UI. becoz first one is 0, mns false and it is with AND so first one will be returned
instead do this
	{arr.length===0 && arr[0]}

	
---

Capitalized types indicate that the JSX tag is referring to a React component. 
These tags get compiled into a direct reference to the named variable, so if you use the JSX <Foo /> expression, Foo must be in scope.

---

Since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code.

	import React from 'react';
	function WarningButton() {
	  return <div color="red" />;
	}
In the above code if you remove import statement then error will come. 
thoug react is not used directl but after compiling it will transform into React.createElement('div', ...)

--

JSX children:-
In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. 
There are several different ways to pass children:

	<MyComponent>Hello world!</MyComponent>				:	props.children ->	"Hello world!"
			
	<MyComponent>										:	props.children ->	[MyFirstComponent, MySecondComponent]
	  <MyFirstComponent />
	  <MySecondComponent />
	</MyComponent>

	<MyComponent> 										:	props.children ->	[MyFirstComponent, MySecondComponent]
		[MyFirstComponent, MySecondComponent] 
	</MyComponent>

Functions as Children

	<MyComponent>
		{ (name)=> <div> {name} </div>}
	</MyComponent>
	
	MyComponent(props) {
		return props.children('muf')
	}
-------


In below code you can observe that we imported the React but never used it. But why? 
It is beacuse if we are using JSX then we will have to import React. becoz in the end 
those lines will be changed to React.createElement(...) after passing from JSX transpiler.

	import React from 'react';
	function WarningButton() { return <CustomButton color="red" />;}

If not imported then-
	 'React' must be in scope when using JSX   react/react-in-jsx-scope
	
----------------
Multi-mini component in one object : -
	const Messages = {
		Error: (props) => <div> I am Error </div>
		Warnig: (props) => <div> I am Warnig </div>
		Logger: (props) => <div> I am Logger </div>
	} 
	var App = (props) => {
		return 	<div>
					<Messages.Error />
					<Messages.Warnig />
					<Messages.Logger />
				</div>
	}
----------
If you pass no value for a prop, it defaults to true. These two JSX expressions are equivalent:
	<MyTextBox autocomplete />
	<MyTextBox autocomplete={true} />

-----------

render props :-
First of all it has nothing to do with the 'render' function of lifecycle.

see below code:-
	<Parent pch1={<Pch1 />} pch2={<Pch2 />}>
		<JsxChild />
	</Patent>
	
	Patent(props) {
		<div>  props.pch1 </div>
		<div>  props.children </div>
		<div>  props.pch2 </div>
	}
This is very obvious what will happen here, so no need to dive.
Now observe here all three props are static variable. whatever come from the parent they will have to render it whothout any second thought.

What if this three are a function and can perform some operation then do the rendering.
Yes it is possible and this is we called render props.

so render props are nothing but a function ho can render dynamically.

	<Parent dyn1={(par1, par2) => <div> {par1 + par2}} </div> />
		{(jpar1, jpar2) => <div> {jpar1 + jpar2}} </div> /> }
	</Patent>

	Patent(props) {
		<div>  props.dyn1('rsh', 'sha') </div>
		<div>  props.children('muf', 'hus') </div>
	}
--------------------------------------------------------------------------------------------------------

dangerouslySetInnerHTML: -
dangerouslySetInnerHTML is React’s replacement for using innerHTML in the browser DOM.
you can set HTML directly from React,just pass an object with a __html key
	
		<div dangerouslySetInnerHTML={ {__html: 'First &middot; Second'} } />;

setting HTML from code is dangerous because it’s easy to inadvertently expose your users to a cross-site scripting (XSS) attack.

-----------

style:-
recomendded ways is to use class always.
But still if you wants then
The style attribute accepts a JavaScript object with camelCased properties

eg:
	<div style={{ color: 'black' }}>
	  Hello World!
	</div>
	
----------------------------------------------

#REFCODESPLIT
Lazy loading of comp/Code splitting:-

Suppose you have a large modular app which has large subapps like about, users, profile, cart etc.
They all are independent and free from others.
if user is on one supapp then why we need to load others.
For this react introduce lazy and suspense feature.

It enable you to load only required part of you apps and let the other ignored.

This work perfecly with Router
see below-
	import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
	import React, { Suspense, lazy } from 'react';

	const Home = lazy(() => import('./routes/Home'));
	const About = lazy(() => import('./routes/About'));

	const App = () => (
	  <Router>
		<Suspense fallback={<div>Loading...</div>}>
		  <Switch>
			<Route exact path="/" component={Home}/>
			<Route path="/about" component={About}/>
		  </Switch>
		</Suspense>
	  </Router>
	);
-----------------------

constructor vs componentWillMount; what a ...
 This is very confused topic, firstly if you are using ES6 then calling API either in willMount/constructor will behave same.
 But if you are using ES5 and creating the component by React.createclass(...), then you do not at all have any constructor function so you must use willMount.
 Also do not confuse-> if you wants to be sure that UI must have been properly rendered before api call, then call the api in didMount
